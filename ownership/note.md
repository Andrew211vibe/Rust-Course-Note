### 所有权

有别于以往的GC机制实现的内存安全（会带来性能、内存占用等问题），Rust使用了**所有权系统**

* **垃圾回收机制(GC)** ，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
* **手动管理内存的分配和释放** , 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
* **通过所有权来管理内存** ，编译器在编译时会根据一系列规则进行检查（只发生在编译期，对于程序的运行期，不会有任何性能上的损失）

#### 一段不安全的代码

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

- 变量 `a`和 `c`都是局部变量存储在栈中，函数结束后会将变量 `a`的地址返回，但在离开作用域后，`a`所申请的栈上内存会被系统回收，造成**悬空指针**问题
- 变量 `c`的值是一个常量字符串，存储域常量区，直到程序结束后系统才会回收这片内存

#### 栈和堆

- Rust中，值位于栈还是堆将会影响程序的行为和性能

> 栈（**后进先出**） -- 按照顺序存储值并以相反顺序输出值，增加数据是**进栈**，移出数据是**出栈**
>
> - 栈中的所有数据都必须占用已知且固定大小的内存空间
>
> 堆 -- 用于存储大小未知或可能变化的数据，通过指针访问存取在堆上分配的内存实现数据的存取
>
> - 当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针** , 该过程被称为**在堆上分配内存**
> - 接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的 **指针** ，来获取数据在堆上的实际内存位置，进而访问该数据

##### 性能区别

> 在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。
>
> 在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。

#### 所有权原则

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

##### String类型简介

```rust
let x = "hello";
```

* **字符串字面值是不可变的** ，因为被硬编码到程序代码中
* 并非所有字符串的值都能在编写代码时得知
* 字符串字面值类型 `&str`
* 动态字符串类型 `String`，分配到堆上

```rust
let s = String::from("Hello");

s.push_str(",world!"); // 追加字符串

println!("{}", s);
```

- `::`是一种调用操作符

#### 变量绑定背后的数据交互

```rust
// 代码首先将 5 绑定到变量 x，接着拷贝 x 的值赋给 y，最终 x 和 y 都等于 5
let x = 5;
let y = x;
```

- Rust基本类型，固定大小，通过**自动拷贝**的方式赋值，都存放于栈中
- 整个过程中的赋值都是通过值拷贝的方式完成(发生在栈中)，因此并不需要所有权转移

```rust
let s1 = String::from("Hello");
let s2 = s1;
```

- `String`存储在堆上，无法自动拷贝
- `String`是一个复杂类型，由存储在栈中的**堆指针**、**字符串长度**、**字符串容量**共同组成

  - 堆指针指向真是存储字符串内容的堆内存
  - 长度是目前已使用的大小
  - 容量是堆内存分配空间的大小
- **当 `s1` 被赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了**

  - 拷贝所有数据（**深拷贝**）需要耗费大量性能
  - **浅拷贝** -- 拷贝 `String`本身（8字节指针、8字节长度、8字节容量），但在离开作用域时会发生二次释放问题（`s1`和 `s2`试图释放同一块内存）
    - Rust中称为**移动move**，因为它同时使被拷贝变量无效了

```rust
let s1 = String::from("hello");
let s2 = s1;
// 代码将会因为s1的所有权转移变成无效引用而报错
println!("{}, world!", s1);
```

```rust
fn main() {
    let x: &str = "hello, world";
    let y = x;
    println!("{},{}",x,y);
}
```

- 上述代码 `x` 只是引用了存储在二进制可执行文件( binary )中的字符串 `"hello, world"`，并没有持有所有权
- 因此 `let y = x` 中，仅仅是对该引用进行了拷贝，此时 `y` 和 `x` 都引用了同一个字符串

##### 深拷贝

- **Rust 永远也不会自动创建数据的 “深拷贝”**
- 因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小

```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // 使用clone方法将s1指向的堆中的数据深拷贝到s2（注意性能开销）

println!("s1 = {}, s2 = {}", s1, s2);
```

##### 浅拷贝

- 基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的
- ```rust
  let x = 5;
  let y = x;

  println!("x = {}, y = {}", x, y);
  ```
- Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型

  - 如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程
  - **任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**
  - 一些 `Copy` 的类型：
    - 所有整数类型，比如 `u32`
    - 布尔类型，`bool`，它的值是 `true` 和 `false`
    - 所有浮点数类型，比如 `f64`
    - 字符类型，`char`
    - 元组，当且仅当其包含的类型也都是 `Copy` 的时候
    - 不可变引用 `&T` ，**但是注意: 可变引用 `&mut T` 是不可以 `Copy`的**
- 当所有权转移时，可变性也可以随之改变

```rust
fn main() {
    let s = String::from("hello, ");
  
    // 只修改下面这行代码 !
    let mut s1 = s;

    s1.push_str("world");
    println!("{}", s1);
}
```

#### 函数传值与返回

- 将值传递给函数，一样会发生 `移动` 或者 `复制`

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效
    // println!("在move进函数后使用s: {}", s); // 报错无效的引用

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动到函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作

```

- 函数返回值所有权同理

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

#### 部分移动move

- 当解构一个变量时，可以同时使用 `move` 和引用模式绑定的方式。当这么做时，部分 `move` 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用
- 在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分

```rust
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box<u8>,
    }

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`
    // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &person.age 
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它
    //println!("The person struct is {:?}", person);

    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用
    println!("The person's age from person struct is {}", person.age);
}
```
